# BackPanel

Create HTML user interfaces with a F# DSL and an embedded HTTP server.

TLDR: [BackPanel Example] | [BackPanel NuGet]

## Why

Because some of my .NET services need a user interface for configuring settings while they run.

And also there is currently no simple way to create platform independent user interfaces for dotnet core applications, so HTML seems to be only option.

And furthermore, client side programming with JavaScript or [whatever technology][Fable] that creates JavaScript is not my thing, so I want everything to be rendered on the server side. After all, BackPanel UIs are not meant to be used remotely, so server side rendering should be fast enough.

## What

BackPanel provides a [Docbook] inspired DSL to specify a user interface which is translated to HTML and served via [Suave].

In addition to that, BackPanel follows the [Elm Architecture] for the creation of the user interface. For a simple one like the [BackPanel Example] only two methods need to be implemented:

- The `view` function takes in a model and creates the document.
- The `update` function updates the view model in response to events.

### Document DSL

To create a document, the [Document DSL] must be used. At the time of this writing, the document grammar and its elements are neither complete nor final. A final and stable version will be indicated by a release of [Version 1.0].

## How

Batteries are included. If you add the [BackPanel NuGet] to your project, it comes with [Suave], [Bootstrap], and [FlatUI]. There is no need to use a single line of JavaScript, HTML, or CSS. The F# [Document DSL] should cover everything to build the UI. And if it does not, pull requests are appreciated.

Once the server starts serving the UI and the user opens the URL it is listening at, an `index.html` page with no content is delivered to the browser. This page loads a JavaScript file that connects back to server utilizing a WebSocket. This WebSocket stays connected for the time the page is open. Whenever the server has new content, it sends it to the browser and whenever the user triggers an event, the browser sends the event to the server.

The content is delivered with a JSON encoded DOM representation and rendered by [picodom] on the client. Incremental updates are required to avoid confusing the view state of the browser.

The JavaScript event handlers that are attached to the HTML elements, are generated by the server and respresented as JSON serializations of the original F# event types that are specified in the document.

## FAQ

Here are a few answeres to questions you may have in mind.

### FlatUI is boring, can I change the style?

There is no simple way to do this right now, because some code in the [BackPanel Client] is specifically tailored to [FlatUI].

### How can the view model be changed from within the application.

The BackPanel server implements a `Post` function, that delivers an event to the `update` function, updates the model, renders a view, and sends it to the browser.

### How can user events delivered to the application.

TBD. 

ATM this is only possible by hooking into the `update` function.

But I am planning to implement a simple event in the instance that is returned when the server starts up. This way the `update` function does not need to be tainted with delegating events that do not change the view model.

## License

[MIT License]
Copyright 2017 Armin Sander

[Docbook]: http://docbook.org/
[Suave]: https://suave.io/
[Bootstrap]: http://getbootstrap.com/
[FlatUI]: http://designmodo.github.io/Flat-UI/
[Elm Architecture]: https://guide.elm-lang.org/architecture/
[BackPanel NuGet]: https://www.myget.org/feed/pragmatrix/package/nuget/BackPanel
[BackPanel Example]: BackPanel.Example/Program.fs
[Document DSL]: BackPanel/Document.fs
[Version 1.0]: https://github.com/pragmatrix/backpanel/milestone/1
[BackPanel Client]: BackPanel.Client/backpanel.ts
[Fable]: http://fable.io
[MIT License]: https://opensource.org/licenses/MIT
[picodom]: https://github.com/picodom/picodom
